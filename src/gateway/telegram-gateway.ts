import TelegramBot, { type Message } from "node-telegram-bot-api";
import fs from "node:fs";
import path from "node:path";

import type { AgentProgressUpdate, CronJob, OpenPocketConfig } from "../types";
import { saveConfig } from "../config";
import { AgentRuntime } from "../agent/agent-runtime";
import { EmulatorManager } from "../device/emulator-manager";
import { HumanAuthBridge } from "../human-auth/bridge";
import { LocalHumanAuthStack } from "../human-auth/local-stack";
import { ChatAssistant } from "./chat-assistant";
import { CronService, type CronRunResult } from "./cron-service";
import { HeartbeatRunner } from "./heartbeat-runner";

export const TELEGRAM_MENU_COMMANDS: TelegramBot.BotCommand[] = [
  { command: "start", description: "Start or resume chat onboarding" },
  { command: "help", description: "Show command help" },
  { command: "context", description: "Inspect injected prompt context" },
  { command: "status", description: "Show gateway and emulator status" },
  { command: "model", description: "Show or switch model profile" },
  { command: "startvm", description: "Start Android emulator" },
  { command: "stopvm", description: "Stop Android emulator" },
  { command: "hidevm", description: "Hide emulator window" },
  { command: "showvm", description: "Show emulator window" },
  { command: "screen", description: "Capture manual screenshot" },
  { command: "skills", description: "List loaded skills" },
  { command: "clear", description: "Clear chat memory only" },
  { command: "reset", description: "Clear chat memory and stop task" },
  { command: "stop", description: "Stop current running task" },
  { command: "restart", description: "Restart gateway process loop" },
  { command: "cronrun", description: "Trigger cron job by id" },
  { command: "auth", description: "Human auth helper commands" },
  { command: "run", description: "Force task mode with text" },
];

export interface TelegramGatewayOptions {
  onLogLine?: (line: string) => void;
  typingIntervalMs?: number;
  logger?: (line: string) => void;
}

type ProgressNarrationState = {
  lastNotifiedProgress: AgentProgressUpdate | null;
  skippedSteps: number;
  recentProgress: AgentProgressUpdate[];
};

export class TelegramGateway {
  private readonly config: OpenPocketConfig;
  private readonly emulator: EmulatorManager;
  private readonly agent: AgentRuntime;
  private readonly bot: TelegramBot;
  private readonly cron: CronService;
  private readonly heartbeat: HeartbeatRunner;
  private readonly humanAuth: HumanAuthBridge;
  private readonly localHumanAuthStack: LocalHumanAuthStack;
  private localHumanAuthActive = false;
  private chat: ChatAssistant;
  private readonly writeLogLine: (line: string) => void;
  private readonly typingIntervalMs: number;
  private readonly typingSessions = new Map<number, { refs: number; timer: NodeJS.Timeout }>();
  private lastSyncedBotDisplayName: string | null = null;
  private running = false;
  private stoppedPromise: Promise<void> | null = null;
  private stopResolver: (() => void) | null = null;

  constructor(config: OpenPocketConfig, options?: TelegramGatewayOptions) {
    this.config = config;
    this.emulator = new EmulatorManager(config);
    this.agent = new AgentRuntime(config);
    this.chat = new ChatAssistant(config);
    const onLogLine = options?.onLogLine ?? null;
    const logger =
      options?.logger ??
      ((line: string) => {
        // eslint-disable-next-line no-console
        console.log(line);
      });
    this.writeLogLine = (line: string) => {
      logger(line);
      onLogLine?.(line);
    };
    this.typingIntervalMs = Math.max(50, Math.round(options?.typingIntervalMs ?? 4000));

    const token =
      config.telegram.botToken.trim() ||
      (config.telegram.botTokenEnv ? process.env[config.telegram.botTokenEnv]?.trim() : "") ||
      "";

    if (!token) {
      throw new Error(
        `Telegram bot token is empty. Set config.telegram.botToken or env ${config.telegram.botTokenEnv}.`,
      );
    }

    this.bot = new TelegramBot(token, {
      polling: {
        interval: 1000,
        params: {
          timeout: config.telegram.pollTimeoutSec,
        },
      },
    });

    this.humanAuth = new HumanAuthBridge(config);
    this.localHumanAuthStack = new LocalHumanAuthStack(config, (line) => this.writeLogLine(line));

    this.heartbeat = new HeartbeatRunner(config, {
      log: (line) => {
        this.writeLogLine(line);
      },
      readSnapshot: () => {
        const status = this.emulator.status();
        return {
          busy: this.agent.isBusy(),
          currentTask: this.agent.getCurrentTask(),
          taskRuntimeMs: this.agent.getCurrentTaskRuntimeMs(),
          devices: status.devices.length,
          bootedDevices: status.bootedDevices.length,
        };
      },
    });

    this.cron = new CronService(config, {
      runTask: async (job) => this.runScheduledJob(job),
      log: (line) => {
        this.writeLogLine(line);
      },
    });
  }

  private log(message: string): void {
    const line = `[OpenPocket][gateway] ${new Date().toISOString()} ${message}`;
    this.writeLogLine(line);
  }

  isRunning(): boolean {
    return this.running;
  }

  private compact(text: string, maxChars: number): string {
    const oneLine = text.replace(/\s+/g, " ").trim();
    if (oneLine.length <= maxChars) {
      return oneLine;
    }
    return `${oneLine.slice(0, Math.max(0, maxChars - 3))}...`;
  }

  private sanitizeForChat(text: string, maxChars: number): string {
    const withoutInternalLines = text
      .split("\n")
      .filter((line) => !/^\s*(Session|Auto skill|Auto script)\s*:/i.test(line))
      .join("\n");

    const redacted = withoutInternalLines
      .replace(/local_screenshot=\S+/gi, "local_screenshot=[saved locally]")
      .replace(/runDir=\S+/gi, "runDir=[local-dir]")
      .replace(/\/(?:Users|home|var|tmp)\/[^\s)\]]+/g, "[local-path]")
      .replace(/[A-Za-z]:\\[^\s)\]]+/g, "[local-path]");

    return this.compact(redacted, maxChars);
  }

  private normalizeBotDisplayName(input: string): string {
    const normalized = input.replace(/\s+/g, " ").trim();
    if (!normalized) {
      return "";
    }
    // Telegram bot display name max length is 64 chars.
    return normalized.slice(0, 64);
  }

  private readAssistantNameFromIdentity(): string {
    const identityPath = path.join(this.config.workspaceDir, "IDENTITY.md");
    if (!fs.existsSync(identityPath)) {
      return "";
    }
    let raw = "";
    try {
      raw = fs.readFileSync(identityPath, "utf-8");
    } catch {
      return "";
    }
    // Match "- Name:" only inside the "## Agent Identity" section to avoid
    // picking up unrelated Name bullets from other sections.
    const sectionMatch = raw.match(/##\s*Agent\s+Identity\b[\s\S]*?(?=\n##\s|\n#\s|$)/i);
    const section = sectionMatch ? sectionMatch[0] : raw;
    const match = section.match(/^\s*-\s*Name\s*:\s*(.+)$/im);
    if (!match?.[1]) {
      return "";
    }
    return this.normalizeBotDisplayName(match[1]);
  }

  private async syncBotDisplayNameFromIdentity(): Promise<void> {
    const assistantName = this.readAssistantNameFromIdentity();
    if (!assistantName || assistantName === this.lastSyncedBotDisplayName) {
      return;
    }
    try {
      await this.bot.setMyName({ name: assistantName });
      this.lastSyncedBotDisplayName = assistantName;
      this.log(`telegram bot display name startup-sync name=${JSON.stringify(assistantName)}`);
    } catch (error) {
      this.log(`telegram bot display name startup-sync failed: ${(error as Error).message}`);
    }
  }

  /**
   * Shared helper: run onboarding seed through chat.decide and send the reply.
   * Returns true if onboarding message was sent, false if onboarding is not pending.
   */
  private async trySendOnboardingReply(chatId: number, locale: "zh" | "en"): Promise<boolean> {
    if (!this.chat.isOnboardingPending()) {
      return false;
    }
    const onboardingSeed = locale === "zh" ? "你好" : "hello";
    const decision = await this.chat.decide(chatId, onboardingSeed);
    const reply = decision.reply || (
      locale === "zh"
        ? "我们先做一个简短初始化。"
        : "Let's do a quick onboarding first."
    );
    await this.bot.sendMessage(chatId, this.sanitizeForChat(reply, 1800));
    const profileUpdate = this.chat.consumePendingProfileUpdate(chatId);
    if (profileUpdate) {
      await this.syncBotDisplayName(chatId, profileUpdate.assistantName, profileUpdate.locale);
    }
    return true;
  }

  private buildContextSummaryMessage(): string {
    const report = this.agent.getWorkspacePromptContextReport();
    const lines = [
      "Workspace prompt context report:",
      `- limits: per-file=${report.maxCharsPerFile}, total=${report.maxCharsTotal}`,
      `- included chars: ${report.totalIncludedChars}`,
      `- bootstrap hook applied: ${report.hookApplied}`,
      "- files:",
    ];
    for (const file of report.files) {
      const status = file.included ? "included" : file.budgetExhausted ? "budget-exhausted" : "skipped";
      lines.push(
        `  - ${file.fileName}: ${status}`
        + `, missing=${file.missing}, truncated=${file.truncated}, chars=${file.includedChars}/${file.originalChars}`,
      );
    }
    lines.push("Use `/context detail <fileName>` to inspect one snippet.");
    return lines.join("\n");
  }

  private buildContextDetailMessage(target: string): string {
    const report = this.agent.getWorkspacePromptContextReport();
    const normalizedTarget = target.trim().toLowerCase();
    if (!normalizedTarget) {
      return "Usage: /context detail <fileName>";
    }
    const file = report.files.find((item) => item.fileName.toLowerCase() === normalizedTarget);
    if (!file) {
      return `Unknown context file: ${target}`;
    }
    if (!file.included || !file.snippet) {
      return `No injected snippet for ${file.fileName} (missing=${file.missing}).`;
    }
    const snippet = file.snippet.length > 2200
      ? `${file.snippet.slice(0, 2200)}\n...[detail truncated]`
      : file.snippet;
    return [
      `${file.fileName}`,
      `included=${file.included}, missing=${file.missing}, truncated=${file.truncated}, chars=${file.includedChars}/${file.originalChars}`,
      "",
      snippet,
    ].join("\n");
  }

  private inferLocale(message: Message): "zh" | "en" {
    const languageCode = String(message.from?.language_code ?? "").toLowerCase();
    if (languageCode.startsWith("zh")) {
      return "zh";
    }
    const text = message.text ?? "";
    return /[\u4e00-\u9fff]/.test(text) ? "zh" : "en";
  }

  private inferTaskLocale(task: string): "zh" | "en" {
    return /[\u4e00-\u9fff]/.test(task) ? "zh" : "en";
  }

  private async syncBotDisplayName(
    chatId: number,
    assistantName: string,
    locale: "zh" | "en",
  ): Promise<void> {
    const nextName = this.normalizeBotDisplayName(assistantName);
    if (!nextName) {
      return;
    }
    if (this.lastSyncedBotDisplayName === nextName) {
      return;
    }

    try {
      await this.bot.setMyName({ name: nextName });
      this.lastSyncedBotDisplayName = nextName;
      this.log(`telegram bot display name updated chat=${chatId} name=${JSON.stringify(nextName)}`);
      await this.bot.sendMessage(
        chatId,
        locale === "zh"
          ? `已同步 Telegram Bot 显示名：${nextName}`
          : `Telegram bot display name updated: ${nextName}`,
      );
    } catch (error) {
      this.log(
        `telegram bot display name update failed chat=${chatId} name=${JSON.stringify(nextName)} error=${(error as Error).message}`,
      );
      await this.bot.sendMessage(
        chatId,
        locale === "zh"
          ? `我已保存名字“${nextName}”，但同步 Telegram Bot 显示名失败：${(error as Error).message}`
          : `I saved name "${nextName}", but failed to sync Telegram bot display name: ${(error as Error).message}`,
      );
    }
  }

  async start(): Promise<void> {
    if (this.running) {
      return;
    }
    this.running = true;
    this.stoppedPromise = new Promise<void>((resolve) => {
      this.stopResolver = resolve;
    });

    this.bot.on("message", this.handleMessage);
    this.bot.on("polling_error", this.handlePollingError);
    await this.configureBotCommandMenu();
    await this.syncBotDisplayNameFromIdentity();

    if (this.config.humanAuth.enabled && this.config.humanAuth.useLocalRelay) {
      try {
        const started = await this.localHumanAuthStack.start();
        this.config.humanAuth.relayBaseUrl = started.relayBaseUrl;
        this.config.humanAuth.publicBaseUrl = started.publicBaseUrl;
        this.localHumanAuthActive = true;
        this.log(
          `human-auth local stack ready relay=${started.relayBaseUrl} public=${started.publicBaseUrl}`,
        );
      } catch (error) {
        this.localHumanAuthActive = false;
        this.log(`human-auth local stack failed: ${(error as Error).message}`);
      }
    }

    this.heartbeat.start();
    this.cron.start();
    this.log("telegram polling started");
    this.log("OpenPocket Telegram gateway running...");
  }

  async stop(reason = "manual"): Promise<void> {
    if (!this.running) {
      return;
    }
    this.running = false;
    this.bot.removeListener("message", this.handleMessage);
    this.bot.removeListener("polling_error", this.handlePollingError);
    this.heartbeat.stop();
    this.cron.stop();
    this.clearTypingSessions();
    if (this.localHumanAuthActive) {
      await this.localHumanAuthStack.stop();
      this.localHumanAuthActive = false;
    }
    try {
      await this.bot.stopPolling();
    } catch {
      // Ignore stop polling errors on shutdown.
    }
    this.log(`gateway stopped reason=${reason}`);
    this.stopResolver?.();
    this.stopResolver = null;
  }

  async runForever(): Promise<void> {
    await this.start();
    await this.waitForStop();
  }

  async waitForStop(): Promise<void> {
    if (!this.stoppedPromise) {
      return;
    }
    await this.stoppedPromise;
  }

  private readonly handlePollingError = (error: Error): void => {
    this.log(`polling error: ${error.message}`);
  };

  private readonly handleMessage = async (message: Message): Promise<void> => {
    const chatId = message.chat.id;
    try {
      this.log(`incoming chat=${chatId} text=${JSON.stringify(message.text ?? "")}`);
      const text = message.text?.trim() ?? "";
      const shouldType = Boolean(text) && this.allowed(chatId);
      if (shouldType) {
        await this.withTypingStatus(chatId, async () => {
          await this.consumeMessage(message);
        });
      } else {
        await this.consumeMessage(message);
      }
    } catch (error) {
      this.log(`handler error chat=${chatId} error=${(error as Error).message}`);
      await this.bot.sendMessage(chatId, `OpenPocket error: ${(error as Error).message}`);
    }
  };

  private clearTypingSessions(): void {
    for (const session of this.typingSessions.values()) {
      clearInterval(session.timer);
    }
    this.typingSessions.clear();
  }

  private async sendTypingAction(chatId: number): Promise<void> {
    try {
      await this.bot.sendChatAction(chatId, "typing");
    } catch {
      // Ignore chat action failures to keep task execution stable.
    }
  }

  private beginTypingStatus(chatId: number): () => void {
    const existing = this.typingSessions.get(chatId);
    if (existing) {
      existing.refs += 1;
    } else {
      const timer = setInterval(() => {
        void this.sendTypingAction(chatId);
      }, this.typingIntervalMs);
      timer.unref?.();
      this.typingSessions.set(chatId, { refs: 1, timer });
      void this.sendTypingAction(chatId);
    }

    let released = false;
    return () => {
      if (released) {
        return;
      }
      released = true;
      const session = this.typingSessions.get(chatId);
      if (!session) {
        return;
      }
      session.refs -= 1;
      if (session.refs <= 0) {
        clearInterval(session.timer);
        this.typingSessions.delete(chatId);
      }
    };
  }

  private async withTypingStatus<T>(
    chatId: number | null,
    operation: () => Promise<T>,
  ): Promise<T> {
    if (chatId === null) {
      return operation();
    }
    const release = this.beginTypingStatus(chatId);
    try {
      return await operation();
    } finally {
      release();
    }
  }

  private async configureBotCommandMenu(): Promise<void> {
    try {
      await this.bot.setMyCommands(TELEGRAM_MENU_COMMANDS);
      await this.bot.setChatMenuButton({
        menu_button: {
          type: "commands",
        },
      });
      this.log(`telegram command menu configured commands=${TELEGRAM_MENU_COMMANDS.length}`);
    } catch (error) {
      this.log(`telegram command menu setup failed: ${(error as Error).message}`);
    }
  }

  private allowed(chatId: number): boolean {
    const allow = this.config.telegram.allowedChatIds;
    if (!allow || allow.length === 0) {
      return true;
    }
    return allow.includes(chatId);
  }

  private isCodeBasedHumanAuthCapability(capability: string): boolean {
    return capability === "sms" || capability === "2fa";
  }

  private normalizeOtpCode(text: string): string | null {
    const compact = text.replace(/\s+/g, "");
    if (/^\d{4,10}$/.test(compact)) {
      return compact;
    }
    return null;
  }

  private async tryResolvePendingOtpFromPlainText(chatId: number, text: string): Promise<boolean> {
    const code = this.normalizeOtpCode(text);
    if (!code) {
      return false;
    }
    const pending = this.humanAuth
      .listPending()
      .filter((item) => item.chatId === chatId && this.isCodeBasedHumanAuthCapability(item.capability));
    if (pending.length !== 1) {
      return false;
    }

    const requestId = pending[0].requestId;
    const resolved = this.humanAuth.resolvePending(
      requestId,
      true,
      code,
      `chat:${chatId}:otp-inline`,
    );
    if (!resolved) {
      return false;
    }

    await this.bot.sendMessage(
      chatId,
      `Received code for ${requestId}: ${code}\nContinuing task execution now.`,
    );
    return true;
  }

  private async consumeMessage(message: Message): Promise<void> {
    const chatId = message.chat.id;
    if (!this.allowed(chatId)) {
      return;
    }

    const text = message.text?.trim();
    if (!text) {
      return;
    }

    if (/^\/start(?:\s.*)?$/i.test(text) && !text.startsWith("/startvm")) {
      const locale = this.inferLocale(message);
      if (await this.trySendOnboardingReply(chatId, locale)) {
        return;
      }

      await this.bot.sendMessage(
        chatId,
        locale === "zh"
          ? "OpenPocket 已就绪。直接发需求即可；发送 /help 查看命令。"
          : "OpenPocket is ready. Send a request directly, or use /help for commands.",
      );
      return;
    }

    if (text.startsWith("/help")) {
      await this.bot.sendMessage(
        chatId,
        [
          "OpenPocket commands:",
          "/start",
          "/context",
          "/context detail <fileName>",
          "/status",
          "/model [name]",
          "/startvm",
          "/stopvm",
          "/hidevm",
          "/showvm",
          "/screen",
          "/skills",
          "/clear",
          "/reset",
          "/stop",
          "/restart",
          "/cronrun <job-id>",
          "/auth",
          "/auth pending",
          "/auth approve <request-id> [note]",
          "/auth reject <request-id> [note]",
          "/run <task>",
          "Send plain text directly. I will auto-route to chat or task mode. Use /run to force task mode.",
        ].join("\n"),
      );
      return;
    }

    if (text.startsWith("/context")) {
      const detailArg = text.replace("/context", "").trim();
      if (!detailArg || /^list$/i.test(detailArg)) {
        await this.bot.sendMessage(chatId, this.sanitizeForChat(this.buildContextSummaryMessage(), 3500));
        return;
      }
      if (/^detail(\s+.+)?$/i.test(detailArg)) {
        const target = detailArg.replace(/^detail\s*/i, "");
        await this.bot.sendMessage(chatId, this.sanitizeForChat(this.buildContextDetailMessage(target), 3500));
        return;
      }
      await this.bot.sendMessage(chatId, this.sanitizeForChat(this.buildContextDetailMessage(detailArg), 3500));
      return;
    }

    if (text.startsWith("/status")) {
      const status = this.emulator.status();
      await this.bot.sendMessage(
        chatId,
        [
          `Project: ${this.config.projectName}`,
          `Model: ${this.config.defaultModel}`,
          `Agent busy: ${this.agent.isBusy()}`,
          `Current task: ${this.agent.getCurrentTask() ?? "(none)"}`,
          `AVD: ${status.avdName}`,
          `Devices: ${status.devices.length > 0 ? status.devices.join(", ") : "(none)"}`,
          `Booted: ${status.bootedDevices.length > 0 ? status.bootedDevices.join(", ") : "(none)"}`,
          `Human auth: ${this.config.humanAuth.enabled ? "enabled" : "disabled"}`,
          `Human auth relay: ${this.config.humanAuth.relayBaseUrl || "(not configured)"}`,
          `Human auth public: ${this.config.humanAuth.publicBaseUrl || "(not configured)"}`,
        ].join("\n"),
      );
      return;
    }

    if (text.startsWith("/model")) {
      const requested = text.replace("/model", "").trim();
      if (!requested) {
        await this.bot.sendMessage(
          chatId,
          `Current model: ${this.config.defaultModel}\nAvailable: ${Object.keys(this.config.models).join(", ")}`,
        );
        return;
      }

      if (!this.config.models[requested]) {
        await this.bot.sendMessage(chatId, `Unknown model: ${requested}`);
        return;
      }

      this.config.defaultModel = requested;
      saveConfig(this.config);
      this.chat = new ChatAssistant(this.config);
      await this.bot.sendMessage(chatId, `Default model updated: ${requested}`);
      return;
    }

    if (text.startsWith("/startvm")) {
      const messageText = await this.emulator.start();
      await this.bot.sendMessage(chatId, messageText);
      return;
    }

    if (text.startsWith("/stopvm")) {
      await this.bot.sendMessage(chatId, this.emulator.stop());
      return;
    }

    if (text.startsWith("/hidevm")) {
      await this.bot.sendMessage(chatId, await this.emulator.ensureHiddenBackground());
      return;
    }

    if (text.startsWith("/showvm")) {
      await this.bot.sendMessage(chatId, await this.emulator.ensureWindowVisible());
      return;
    }

    if (text.startsWith("/screen")) {
      const screenshotPath = await this.agent.captureManualScreenshot();
      this.log(`manual screenshot chat=${chatId} path=${screenshotPath}`);
      await this.bot.sendMessage(chatId, "Screenshot saved in local storage.");
      return;
    }

    if (text.startsWith("/skills")) {
      const skills = this.agent.listSkills();
      if (skills.length === 0) {
        await this.bot.sendMessage(chatId, "No skills loaded.");
        return;
      }
      const body = skills
        .slice(0, 25)
        .map((skill) => `- [${skill.source}] ${skill.name}: ${skill.description}`)
        .join("\n");
      await this.bot.sendMessage(chatId, `Loaded skills (${skills.length}):\n${body}`);
      return;
    }

    if (text === "/clear") {
      this.chat.clear(chatId);
      await this.bot.sendMessage(chatId, "Conversation memory cleared.");
      return;
    }

    if (text === "/reset") {
      this.chat.clear(chatId);
      const accepted = this.agent.stopCurrentTask();
      const locale = this.inferLocale(message);
      const resetSummary = accepted
        ? "Conversation memory cleared. Stop requested for the running task."
        : "Conversation memory cleared. No running task to stop.";
      await this.bot.sendMessage(chatId, resetSummary);

      if (await this.trySendOnboardingReply(chatId, locale)) {
        return;
      }

      await this.bot.sendMessage(chatId, this.sanitizeForChat(this.chat.sessionResetPrompt(locale), 1800));
      return;
    }

    if (text === "/stop") {
      const accepted = this.agent.stopCurrentTask();
      await this.bot.sendMessage(chatId, accepted ? "Stop requested." : "No running task.");
      return;
    }

    if (text === "/restart") {
      if (process.listenerCount("SIGUSR1") === 0) {
        await this.bot.sendMessage(
          chatId,
          "Restart is unavailable in the current runtime mode (no gateway run-loop signal handler).",
        );
        return;
      }
      await this.bot.sendMessage(chatId, "Gateway restart requested. Reconnecting...");
      setTimeout(() => {
        try {
          process.kill(process.pid, "SIGUSR1");
        } catch (error) {
          this.log(`gateway restart signal failed: ${(error as Error).message}`);
        }
      }, 50);
      return;
    }

    if (text.startsWith("/cronrun")) {
      const jobId = text.replace("/cronrun", "").trim();
      if (!jobId) {
        await this.bot.sendMessage(chatId, "Usage: /cronrun <job-id>");
        return;
      }
      const found = await this.cron.runNow(jobId);
      await this.bot.sendMessage(chatId, found ? `Cron job triggered: ${jobId}` : `Cron job not found: ${jobId}`);
      return;
    }

    if (text.startsWith("/run")) {
      const task = text.replace("/run", "").trim();
      if (!task) {
        await this.bot.sendMessage(chatId, "Usage: /run <task>");
        return;
      }
      await this.runTaskAsync(chatId, task);
      return;
    }

    if (text.startsWith("/auth")) {
      await this.handleAuthCommand(chatId, text);
      return;
    }

    if (await this.tryResolvePendingOtpFromPlainText(chatId, text)) {
      return;
    }

    const decision = await this.chat.decide(chatId, text);
    this.log(
      `decision chat=${chatId} mode=${decision.mode} confidence=${decision.confidence.toFixed(2)} reason=${decision.reason}`,
    );
    if (decision.mode === "task") {
      const task = decision.task || text;
      await this.runTaskAsync(chatId, task);
      return;
    }

    const reply = decision.reply || (await this.chat.reply(chatId, text));
    await this.bot.sendMessage(chatId, this.sanitizeForChat(reply, 1800));
    const profileUpdate = this.chat.consumePendingProfileUpdate(chatId);
    if (profileUpdate) {
      await this.syncBotDisplayName(chatId, profileUpdate.assistantName, profileUpdate.locale);
    }
  }

  private async runTaskAsync(chatId: number, task: string): Promise<void> {
    if (this.agent.isBusy()) {
      this.log(`task rejected busy chat=${chatId} task=${JSON.stringify(task)}`);
      await this.bot.sendMessage(chatId, "A previous task is still running. Please wait.");
      return;
    }
    const locale = this.inferTaskLocale(task);
    await this.bot.sendMessage(
      chatId,
      locale === "zh"
        ? `任务已接收：${task}\n我会让模型判断何时值得播报，只在有明确进展时同步，不会每一步刷屏。`
        : `Task accepted: ${task}\nI will let the model decide when progress is meaningful, instead of sending every single step.`,
    );
    void this.runTaskAndReport({ chatId, task, source: "chat", modelName: null });
  }

  private async runScheduledJob(job: CronJob): Promise<CronRunResult> {
    if (this.agent.isBusy()) {
      return {
        accepted: false,
        ok: false,
        message: "Agent is busy.",
      };
    }

    if (job.chatId !== null) {
      await this.bot.sendMessage(job.chatId, `Scheduled task started (${job.name}): ${job.task}`);
    }

    return this.runTaskAndReport({
      chatId: job.chatId,
      task: job.task,
      source: "cron",
      modelName: job.model,
    });
  }

  private async runTaskAndReport(params: {
    chatId: number | null;
    task: string;
    source: "chat" | "cron";
    modelName: string | null;
  }): Promise<CronRunResult> {
    const { chatId, task, source, modelName } = params;
    const progressLocale = this.inferTaskLocale(task);
    const progressNarrationState: ProgressNarrationState = {
      lastNotifiedProgress: null,
      skippedSteps: 0,
      recentProgress: [],
    };
    let progressWork: Promise<void> = Promise.resolve();
    this.log(
      `task accepted source=${source} chat=${chatId ?? "(none)"} task=${JSON.stringify(task)} model=${modelName ?? this.config.defaultModel}`,
    );

    return this.withTypingStatus(source === "chat" ? chatId : null, async () => {
      const enqueueProgressNarration = (progress: AgentProgressUpdate): void => {
        progressWork = progressWork
          .then(async () => {
            if (chatId === null) {
              return;
            }
            this.log(
              `progress source=${source} chat=${chatId} step=${progress.step}/${progress.maxSteps} action=${progress.actionType} app=${progress.currentApp}`,
            );
            const recentProgress = [...progressNarrationState.recentProgress, progress].slice(-8);
            const decision = await this.chat.narrateTaskProgress({
              task,
              locale: progressLocale,
              progress,
              recentProgress,
              lastNotifiedProgress: progressNarrationState.lastNotifiedProgress,
              skippedSteps: progressNarrationState.skippedSteps,
            });
            if (!decision.notify) {
              progressNarrationState.skippedSteps += 1;
              progressNarrationState.recentProgress = recentProgress;
              return;
            }
            const message = this.sanitizeForChat(decision.message, 1800);
            if (!message.trim()) {
              progressNarrationState.skippedSteps += 1;
              progressNarrationState.recentProgress = recentProgress;
              return;
            }
            progressNarrationState.lastNotifiedProgress = progress;
            progressNarrationState.skippedSteps = 0;
            progressNarrationState.recentProgress = [];
            await this.bot.sendMessage(chatId, message);
          })
          .catch((error) => {
            this.log(
              `progress narration error source=${source} chat=${chatId ?? "(none)"} error=${(error as Error).message}`,
            );
          });
      };

      try {
        const result = await this.agent.runTask(
          task,
          modelName ?? undefined,
          chatId === null
            ? undefined
            : async (progress) => {
                enqueueProgressNarration(progress);
              },
          chatId === null
            ? undefined
            : async (request) => {
                const timeoutSec = Math.max(30, Math.round(request.timeoutSec));
                return this.humanAuth.requestAndWait(
                  { chatId, task, request: { ...request, timeoutSec } },
                  async (opened) => {
                    const isCodeFlow = this.isCodeBasedHumanAuthCapability(request.capability);
                    const lines = [
                      `Human authorization required (${request.capability}).`,
                      `Request ID: ${opened.requestId}`,
                      `Current app: ${request.currentApp}`,
                      `Instruction: ${request.instruction}`,
                      `Reason: ${request.reason || "no reason provided"}`,
                      `Expires at: ${opened.expiresAt}`,
                      "",
                      "Fallback manual commands:",
                      opened.manualApproveCommand,
                      opened.manualRejectCommand,
                    ];

                    if (isCodeFlow) {
                      await this.bot.sendMessage(
                        chatId,
                        [
                          ...lines,
                          "",
                          "Code flow (recommended):",
                          `- reply plain code (4-10 digits), for example: 123456`,
                          `- or run: ${opened.manualApproveCommand} <code>`,
                          `- reject with: ${opened.manualRejectCommand}`,
                          opened.openUrl
                            ? "- web page is optional for SMS/2FA; Telegram code reply is faster."
                            : "- web page is unavailable; use Telegram code reply.",
                        ].join("\n"),
                      );
                      return;
                    }

                    if (opened.openUrl) {
                      await this.bot.sendMessage(chatId, lines.join("\n"), {
                        reply_markup: {
                          inline_keyboard: [
                            [
                              {
                                text: "Open Human Auth",
                                url: opened.openUrl,
                              },
                            ],
                          ],
                        },
                      });
                      return;
                    }

                    await this.bot.sendMessage(
                      chatId,
                      `${lines.join("\n")}\n\nWeb link is unavailable. Use manual approve/reject commands.`,
                    );
                  },
                );
              },
          source === "cron" ? "minimal" : undefined,
        );
        await progressWork;

        this.log(`task done source=${source} chat=${chatId ?? "(none)"} ok=${result.ok} session=${result.sessionPath}`);

        if (chatId !== null) {
          if (result.ok) {
            await this.bot.sendMessage(
              chatId,
              `Task completed.\nResult: ${this.sanitizeForChat(result.message, 800) || "Completed."}`,
            );
          } else {
            await this.bot.sendMessage(
              chatId,
              `Task not completed.\nReason: ${this.sanitizeForChat(result.message, 800) || "Unknown error."}`,
            );
          }
        }

        return {
          accepted: true,
          ok: result.ok,
          message: result.message,
        };
      } catch (error) {
        await progressWork.catch(() => {});
        const message = `Execution interrupted: ${(error as Error).message || "Unknown error."}`;
        this.log(`task crash source=${source} chat=${chatId ?? "(none)"} error=${(error as Error).message}`);
        if (chatId !== null) {
          await this.bot.sendMessage(chatId, this.sanitizeForChat(message, 600));
        }
        return {
          accepted: true,
          ok: false,
          message,
        };
      }
    });
  }

  private async handleAuthCommand(chatId: number, text: string): Promise<void> {
    const parts = text.split(/\s+/).filter(Boolean);
    if (parts.length === 1 || parts[1] === "help") {
      await this.bot.sendMessage(
        chatId,
        [
          "Human auth commands:",
          "/auth pending",
          "/auth approve <request-id> [note]",
          "/auth reject <request-id> [note]",
        ].join("\n"),
      );
      return;
    }

    const sub = parts[1];
    if (sub === "pending") {
      const pending = this.humanAuth.listPending().filter((item) => item.chatId === chatId);
      if (pending.length === 0) {
        await this.bot.sendMessage(chatId, "No pending human-auth requests.");
        return;
      }
      const body = pending
        .slice(0, 20)
        .map(
          (item) =>
            `- ${item.requestId} capability=${item.capability} app=${item.currentApp} expires=${item.expiresAt}`,
        )
        .join("\n");
      await this.bot.sendMessage(chatId, `Pending human-auth requests (${pending.length}):\n${body}`);
      return;
    }

    if (sub === "approve" || sub === "reject") {
      const requestId = parts[2]?.trim();
      if (!requestId) {
        await this.bot.sendMessage(chatId, `Usage: /auth ${sub} <request-id> [note]`);
        return;
      }
      const note = parts.slice(3).join(" ").trim();
      const ok = this.humanAuth.resolvePending(requestId, sub === "approve", note, `chat:${chatId}`);
      await this.bot.sendMessage(
        chatId,
        ok ? `Request ${requestId} ${sub}d.` : `Pending request not found: ${requestId}`,
      );
      return;
    }

    await this.bot.sendMessage(chatId, "Unknown /auth subcommand. Use /auth help.");
  }
}
