import fs from "node:fs";
import path from "node:path";

import type {
  AgentProgressUpdate,
  AgentRunResult,
  HumanAuthDecision,
  HumanAuthCapability,
  HumanAuthRequest,
  OpenPocketConfig,
  SkillInfo,
} from "../types";
import { getModelProfile, resolveModelAuth } from "../config";
import { WorkspaceStore } from "../memory/workspace";
import { ScreenshotStore } from "../memory/screenshot-store";
import { sleep } from "../utils/time";
import { nowIso } from "../utils/paths";
import { AdbRuntime } from "../device/adb-runtime";
import { EmulatorManager } from "../device/emulator-manager";
import { AutoArtifactBuilder, type StepTrace } from "../skills/auto-artifact-builder";
import { SkillLoader } from "../skills/skill-loader";
import { ScriptExecutor } from "../tools/script-executor";
import { ModelClient } from "./model-client";
import { buildSystemPrompt } from "./prompts";
import { scaleCoordinates, drawDebugMarker } from "../utils/image-scale";

const AUTO_PERMISSION_DIALOG_PACKAGES = [
  "permissioncontroller",
  "packageinstaller",
];

const PERMISSION_APPROVE_TEXT_HINTS = [
  "while using",
  "only this time",
  "allow all the time",
  "allow",
  "continue",
  "ok",
  "yes",
  "grant",
  "permit",
];

const PERMISSION_DENY_TEXT_HINTS = [
  "don't allow",
  "dont allow",
  "deny",
  "not now",
  "cancel",
  "no",
];

const PERMISSION_APPROVE_ID_HINTS = [
  "allow",
  "grant",
  "positive",
  "continue",
  "button1",
];

const PERMISSION_DENY_ID_HINTS = [
  "deny",
  "negative",
  "cancel",
  "dont_allow",
  "button2",
  "button3",
];

const SYSTEM_PROMPT_CONTEXT_FILES = [
  "AGENTS.md",
  "BOOTSTRAP.md",
  "SOUL.md",
  "USER.md",
  "IDENTITY.md",
  "TOOLS.md",
  "HEARTBEAT.md",
  "MEMORY.md",
] as const;
const SYSTEM_PROMPT_MAX_CHARS_PER_FILE = 4_000;
const SYSTEM_PROMPT_MAX_CHARS_TOTAL = 18_000;

type DelegationApplyResult = {
  message: string;
  templateHint: string | null;
};

type PermissionDialogNode = {
  text: string;
  contentDesc: string;
  resourceId: string;
  className: string;
  clickable: boolean;
  enabled: boolean;
  left: number;
  top: number;
  right: number;
  bottom: number;
};

export class AgentRuntime {
  private readonly config: OpenPocketConfig;
  private readonly workspace: WorkspaceStore;
  private readonly emulator: EmulatorManager;
  private readonly adb: AdbRuntime;
  private readonly skillLoader: SkillLoader;
  private readonly autoArtifactBuilder: AutoArtifactBuilder;
  private readonly scriptExecutor: ScriptExecutor;
  private readonly screenshotStore: ScreenshotStore;
  private busy = false;
  private stopRequested = false;
  private currentTask: string | null = null;
  private currentTaskStartedAtMs: number | null = null;

  constructor(config: OpenPocketConfig) {
    this.config = config;
    this.workspace = new WorkspaceStore(config);
    this.emulator = new EmulatorManager(config);
    this.adb = new AdbRuntime(config, this.emulator);
    this.skillLoader = new SkillLoader(config);
    this.autoArtifactBuilder = new AutoArtifactBuilder(config);
    this.scriptExecutor = new ScriptExecutor(config);
    this.screenshotStore = new ScreenshotStore(
      config.screenshots.directory,
      config.screenshots.maxCount,
    );
  }

  isBusy(): boolean {
    return this.busy;
  }

  getCurrentTask(): string | null {
    return this.currentTask;
  }

  getCurrentTaskRuntimeMs(): number | null {
    if (!this.currentTaskStartedAtMs) {
      return null;
    }
    return Math.max(0, Date.now() - this.currentTaskStartedAtMs);
  }

  listSkills(): SkillInfo[] {
    return this.skillLoader.loadAll();
  }

  async captureManualScreenshot(): Promise<string> {
    const snapshot = await this.adb.captureScreenSnapshot(this.config.agent.deviceId);
    return this.screenshotStore.save(
      Buffer.from(snapshot.screenshotBase64, "base64"),
      {
        sessionId: "manual",
        step: 0,
        currentApp: snapshot.currentApp,
      },
    );
  }

  stopCurrentTask(): boolean {
    if (!this.busy) {
      return false;
    }
    this.stopRequested = true;
    return true;
  }

  private async safeReturnToHome(): Promise<void> {
    if (!this.config.agent.returnHomeOnTaskEnd) {
      return;
    }

    try {
      const result = await this.adb.executeAction(
        { type: "keyevent", keycode: "KEYCODE_HOME", reason: "task_end_default_reset" },
        this.config.agent.deviceId,
      );
      if (this.config.agent.verbose) {
        // eslint-disable-next-line no-console
        console.log(`[OpenPocket][task-end] ${result}`);
      }
    } catch (error) {
      if (this.config.agent.verbose) {
        // eslint-disable-next-line no-console
        console.log(`[OpenPocket][task-end] failed to return home: ${(error as Error).message}`);
      }
    }
  }

  private readJsonArtifact(artifactPath: string): Record<string, unknown> | null {
    try {
      const raw = fs.readFileSync(artifactPath, "utf-8");
      const parsed = JSON.parse(raw) as unknown;
      if (typeof parsed === "object" && parsed !== null && !Array.isArray(parsed)) {
        return parsed as Record<string, unknown>;
      }
      return null;
    } catch {
      return null;
    }
  }

  private buildWorkspacePromptContext(): string {
    const blocks: string[] = [];
    let remaining = SYSTEM_PROMPT_MAX_CHARS_TOTAL;

    for (const name of SYSTEM_PROMPT_CONTEXT_FILES) {
      if (remaining <= 256) {
        break;
      }
      const filePath = path.join(this.config.workspaceDir, name);
      if (!fs.existsSync(filePath)) {
        continue;
      }

      let raw = "";
      try {
        raw = fs.readFileSync(filePath, "utf-8");
      } catch {
        continue;
      }

      const normalized = raw.replace(/\r\n/g, "\n").trim();
      if (!normalized) {
        continue;
      }

      const perFileLimit = Math.min(SYSTEM_PROMPT_MAX_CHARS_PER_FILE, remaining);
      const truncated = normalized.length > perFileLimit;
      const snippet = truncated
        ? `${normalized.slice(0, Math.max(0, perFileLimit - 24)).trimEnd()}\n...[truncated]`
        : normalized;

      blocks.push(`### ${name}\n${snippet}`);
      remaining -= snippet.length;
    }

    if (blocks.length === 0) {
      return "";
    }

    return [
      "Instruction priority inside workspace context: AGENTS.md > BOOTSTRAP.md > SOUL.md > other files.",
      ...blocks,
    ].join("\n\n");
  }

  private isImageArtifactPath(artifactPath: string): boolean {
    const ext = path.extname(artifactPath).toLowerCase();
    return [".jpg", ".jpeg", ".png", ".webp", ".heic", ".heif", ".bmp", ".gif"].includes(ext);
  }

  private extractDelegatedText(artifactJson: Record<string, unknown> | null): string | null {
    if (!artifactJson) {
      return null;
    }
    const value = artifactJson.value;
    if (typeof value === "string" && value.trim()) {
      return value.trim();
    }
    return null;
  }

  private extractDelegatedTextFromDecisionMessage(message: string): string | null {
    const raw = String(message || "").trim();
    if (!raw) {
      return null;
    }

    const normalized = raw.toLowerCase();
    if (
      normalized.startsWith("approved by ") ||
      normalized.startsWith("rejected by ") ||
      normalized === "approved from web link." ||
      normalized === "rejected from web link."
    ) {
      return null;
    }

    const explicitCode = raw.match(/\b\d{4,10}\b/);
    if (explicitCode?.[0]) {
      return explicitCode[0];
    }

    if (/^[A-Za-z0-9._-]{4,32}$/.test(raw)) {
      return raw;
    }
    return null;
  }

  private extractDelegatedGeo(
    artifactJson: Record<string, unknown> | null,
  ): { lat: number; lon: number } | null {
    if (!artifactJson) {
      return null;
    }
    const lat = Number(artifactJson.lat);
    const lon = Number(artifactJson.lon);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
      return null;
    }
    return { lat, lon };
  }

  private async applyLocationDelegation(lat: number, lon: number): Promise<DelegationApplyResult> {
    const deviceId = this.adb.resolveDeviceId(this.config.agent.deviceId);
    this.emulator.runAdb(
      [
        "-s",
        deviceId,
        "emu",
        "geo",
        "fix",
        String(lon),
        String(lat),
      ],
      20_000,
    );
    return {
      message: `delegated location injected lat=${lat.toFixed(6)} lon=${lon.toFixed(6)}`,
      templateHint: "location_injected_continue_flow",
    };
  }

  private async applyTextDelegation(text: string): Promise<DelegationApplyResult> {
    const result = await this.adb.executeAction(
      {
        type: "type",
        text,
        reason: "human_auth_delegate_text",
      },
      this.config.agent.deviceId,
    );
    return {
      message: `delegated text typed (${text.length} chars): ${result}`,
      templateHint: "text_typed_continue_flow",
    };
  }

  private async applyImageDelegation(artifactPath: string): Promise<DelegationApplyResult> {
    const deviceId = this.adb.resolveDeviceId(this.config.agent.deviceId);
    const ext = path.extname(artifactPath).toLowerCase() || ".jpg";
    const remoteName = `openpocket-human-auth-${Date.now()}${ext}`;
    const remotePath = `/sdcard/Download/${remoteName}`;
    this.emulator.runAdb(
      [
        "-s",
        deviceId,
        "push",
        artifactPath,
        remotePath,
      ],
      30_000,
    );
    try {
      this.emulator.runAdb(
        [
          "-s",
          deviceId,
          "shell",
          "am",
          "broadcast",
          "-a",
          "android.intent.action.MEDIA_SCANNER_SCAN_FILE",
          "-d",
          `file://${remotePath}`,
        ],
        15_000,
      );
    } catch {
      // Media scan broadcast is best-effort.
    }
    return {
      message: `delegated image pushed to ${remotePath}`,
      templateHint:
        `gallery_import_template: tap app upload/attach/gallery entry, open Downloads, select ${remoteName}, then confirm.`,
    };
  }

  private normalizePermissionUiText(value: string): string {
    return value
      .toLowerCase()
      .replace(/[’‘`´]/g, "'")
      .replace(/\s+/g, " ")
      .trim();
  }

  private parseUiNodeAttributes(attributesRaw: string): Record<string, string> {
    const out: Record<string, string> = {};
    const attrRe = /([a-zA-Z0-9_:-]+)="([^"]*)"/g;
    let match = attrRe.exec(attributesRaw);
    while (match) {
      const key = match[1];
      const value = match[2] ?? "";
      out[key] = value;
      match = attrRe.exec(attributesRaw);
    }
    return out;
  }

  private parseBounds(boundsRaw: string): {
    left: number;
    top: number;
    right: number;
    bottom: number;
  } | null {
    const match = boundsRaw.match(/^\[(\d+),(\d+)\]\[(\d+),(\d+)\]$/);
    if (!match) {
      return null;
    }
    const left = Number(match[1]);
    const top = Number(match[2]);
    const right = Number(match[3]);
    const bottom = Number(match[4]);
    if (![left, top, right, bottom].every((value) => Number.isFinite(value))) {
      return null;
    }
    if (right <= left || bottom <= top) {
      return null;
    }
    return { left, top, right, bottom };
  }

  private parsePermissionDialogNodes(uiDumpXml: string): PermissionDialogNode[] {
    const nodes: PermissionDialogNode[] = [];
    const nodeRe = /<node\s+([^>]*?)\/>/g;
    let match = nodeRe.exec(uiDumpXml);
    while (match) {
      const attrs = this.parseUiNodeAttributes(match[1] ?? "");
      const parsedBounds = this.parseBounds(String(attrs.bounds ?? "").trim());
      if (!parsedBounds) {
        match = nodeRe.exec(uiDumpXml);
        continue;
      }
      nodes.push({
        text: String(attrs.text ?? ""),
        contentDesc: String(attrs["content-desc"] ?? ""),
        resourceId: String(attrs["resource-id"] ?? ""),
        className: String(attrs.class ?? ""),
        clickable: String(attrs.clickable ?? "").toLowerCase() === "true",
        enabled: String(attrs.enabled ?? "").toLowerCase() !== "false",
        left: parsedBounds.left,
        top: parsedBounds.top,
        right: parsedBounds.right,
        bottom: parsedBounds.bottom,
      });
      match = nodeRe.exec(uiDumpXml);
    }
    return nodes;
  }

  private scorePermissionNodeCandidate(node: PermissionDialogNode, approved: boolean): number {
    if (!node.enabled) {
      return 0;
    }

    const combined = this.normalizePermissionUiText(
      [node.text, node.contentDesc].filter(Boolean).join(" "),
    );
    const idNormalized = this.normalizePermissionUiText(node.resourceId);
    const textHints = approved ? PERMISSION_APPROVE_TEXT_HINTS : PERMISSION_DENY_TEXT_HINTS;
    const idHints = approved ? PERMISSION_APPROVE_ID_HINTS : PERMISSION_DENY_ID_HINTS;
    let score = 0;

    for (const hint of textHints) {
      if (combined.includes(hint)) {
        score = Math.max(score, hint === "allow" ? 80 : 120);
      }
    }
    for (const hint of idHints) {
      if (idNormalized.includes(hint)) {
        score = Math.max(score, 90);
      }
    }
    if (!node.clickable && !node.className.toLowerCase().includes("button")) {
      score = Math.max(0, score - 40);
    }
    return score;
  }

  private pickPermissionDialogNode(
    nodes: PermissionDialogNode[],
    approved: boolean,
  ): PermissionDialogNode | null {
    if (nodes.length === 0) {
      return null;
    }

    const scored = nodes
      .map((node) => ({
        node,
        score: this.scorePermissionNodeCandidate(node, approved),
      }))
      .filter((item) => item.score > 0)
      .sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        if (approved) {
          if (b.node.right !== a.node.right) {
            return b.node.right - a.node.right;
          }
          return b.node.bottom - a.node.bottom;
        }
        if (a.node.left !== b.node.left) {
          return a.node.left - b.node.left;
        }
        return b.node.bottom - a.node.bottom;
      });

    if (scored.length > 0) {
      return scored[0]?.node ?? null;
    }

    const actionable = nodes.filter(
      (node) => node.enabled && (node.clickable || node.className.toLowerCase().includes("button")),
    );
    if (actionable.length === 0) {
      return null;
    }
    const maxTop = Math.max(...actionable.map((node) => node.top));
    const row = actionable.filter((node) => node.top >= maxTop - 160);
    if (row.length === 0) {
      return null;
    }
    row.sort((a, b) => {
      if (approved) {
        return b.right - a.right;
      }
      return a.left - b.left;
    });
    return row[0] ?? null;
  }

  private resolveDelegationDeviceId(): string {
    const adbLike = this.adb as unknown as {
      resolveDeviceId?: (preferred?: string | null) => string;
    };
    if (typeof adbLike.resolveDeviceId === "function") {
      return adbLike.resolveDeviceId(this.config.agent.deviceId);
    }
    try {
      const status = this.emulator.status();
      if (status.bootedDevices.length > 0) {
        return status.bootedDevices[0];
      }
      if (status.devices.length > 0) {
        return status.devices[0];
      }
    } catch {
      // Ignore status probe failure in tests/mocks.
    }
    return this.config.agent.deviceId || "emulator-5554";
  }

  private isPermissionDialogApp(currentApp: string): boolean {
    const normalized = String(currentApp || "").toLowerCase();
    return AUTO_PERMISSION_DIALOG_PACKAGES.some((token) => normalized.includes(token));
  }

  private async applyPermissionDialogDecision(
    capability: HumanAuthCapability,
    decision: HumanAuthDecision,
    currentApp: string,
  ): Promise<DelegationApplyResult | null> {
    if (decision.status === "timeout") {
      return null;
    }
    const shouldHandle =
      capability === "permission" || this.isPermissionDialogApp(currentApp);
    if (!shouldHandle) {
      return null;
    }

    const deviceId = this.resolveDelegationDeviceId();
    let uiDumpXml = "";
    try {
      this.emulator.runAdb(
        ["-s", deviceId, "shell", "uiautomator", "dump", "/sdcard/openpocket-window.xml"],
        15_000,
      );
      uiDumpXml = this.emulator.runAdb(
        ["-s", deviceId, "shell", "cat", "/sdcard/openpocket-window.xml"],
        15_000,
      );
      if (!uiDumpXml.includes("<hierarchy")) {
        uiDumpXml = this.emulator.runAdb(
          ["-s", deviceId, "shell", "cat", "/sdcard/window_dump.xml"],
          15_000,
        );
      }
    } catch {
      uiDumpXml = "";
    }

    const nodes = this.parsePermissionDialogNodes(uiDumpXml);
    const targetNode = this.pickPermissionDialogNode(nodes, decision.approved);
    if (!targetNode) {
      return {
        message: `permission dialog decision recorded (${decision.status}), but no actionable button was detected`,
        templateHint: null,
      };
    }

    const tapX = Math.max(0, Math.round((targetNode.left + targetNode.right) / 2));
    const tapY = Math.max(0, Math.round((targetNode.top + targetNode.bottom) / 2));
    const label =
      targetNode.text.trim() ||
      targetNode.contentDesc.trim() ||
      targetNode.resourceId.trim() ||
      "(unlabeled)";

    await this.adb.executeAction(
      {
        type: "tap",
        x: tapX,
        y: tapY,
        reason: decision.approved
          ? "human_auth_permission_approve"
          : "human_auth_permission_reject",
      },
      this.config.agent.deviceId,
    );
    await sleep(300);

    return {
      message: `permission dialog ${decision.approved ? "approve" : "reject"} tapped (${tapX}, ${tapY}) label="${label}"`,
      templateHint: null,
    };
  }

  private async applyHumanDelegation(
    capability: HumanAuthCapability,
    decision: HumanAuthDecision,
    currentApp: string,
  ): Promise<DelegationApplyResult | null> {
    const messages: string[] = [];
    let templateHint: string | null = null;

    const permissionDecision = await this.applyPermissionDialogDecision(capability, decision, currentApp);
    if (permissionDecision) {
      messages.push(permissionDecision.message);
      if (permissionDecision.templateHint) {
        templateHint = permissionDecision.templateHint;
      }
    }

    if (!decision.approved || !decision.artifactPath) {
      if (
        decision.approved &&
        !decision.artifactPath &&
        (capability === "sms" || capability === "2fa" || capability === "qr" || capability === "voice")
      ) {
        const fallbackText = this.extractDelegatedTextFromDecisionMessage(decision.message);
        if (fallbackText) {
          const typed = await this.applyTextDelegation(fallbackText);
          messages.push(typed.message);
          if (typed.templateHint) {
            templateHint = typed.templateHint;
          }
        }
      }
      if (messages.length === 0) {
        return null;
      }
      return {
        message: messages.join(" ; "),
        templateHint,
      };
    }
    if (!fs.existsSync(decision.artifactPath)) {
      messages.push(`delegation artifact not found: ${decision.artifactPath}`);
      return {
        message: messages.join(" ; "),
        templateHint,
      };
    }

    try {
      const artifactJson = this.readJsonArtifact(decision.artifactPath);
      let artifactResult: DelegationApplyResult | null = null;

      if (capability === "location") {
        const geo = this.extractDelegatedGeo(artifactJson);
        if (geo) {
          artifactResult = await this.applyLocationDelegation(geo.lat, geo.lon);
        }
      }

      if (!artifactResult && (capability === "sms" || capability === "2fa" || capability === "qr" || capability === "voice")) {
        const text = this.extractDelegatedText(artifactJson);
        if (text) {
          artifactResult = await this.applyTextDelegation(text);
        }
      }

      if (!artifactResult && (artifactJson?.kind === "text" || artifactJson?.kind === "qr_text")) {
        const text = this.extractDelegatedText(artifactJson);
        if (text) {
          artifactResult = await this.applyTextDelegation(text);
        }
      }

      if (!artifactResult && this.isImageArtifactPath(decision.artifactPath)) {
        artifactResult = await this.applyImageDelegation(decision.artifactPath);
      }

      if (!artifactResult) {
        artifactResult = {
          message: `delegation artifact stored at ${decision.artifactPath}`,
          templateHint: null,
        };
      }
      messages.push(artifactResult.message);
      if (artifactResult.templateHint) {
        templateHint = artifactResult.templateHint;
      }
      return {
        message: messages.join(" ; "),
        templateHint,
      };
    } catch (error) {
      messages.push(`delegation apply failed: ${(error as Error).message}`);
      return {
        message: messages.join(" ; "),
        templateHint,
      };
    }
  }

  async runTask(
    task: string,
    modelName?: string,
    onProgress?: (update: AgentProgressUpdate) => Promise<void> | void,
    onHumanAuth?: (request: HumanAuthRequest) => Promise<HumanAuthDecision> | HumanAuthDecision,
  ): Promise<AgentRunResult> {
    if (this.busy) {
      return {
        ok: false,
        message: "Agent is busy. Please retry later.",
        sessionPath: "",
      };
    }

    this.busy = true;
    this.stopRequested = false;
    this.currentTask = task;
    this.currentTaskStartedAtMs = Date.now();
    let shouldReturnHome = false;

    const profileKey = modelName ?? this.config.defaultModel;
    const profile = getModelProfile(this.config, profileKey);
    const session = this.workspace.createSession(task, profileKey, profile.model);
    let lastAutoPermissionAuthAtMs = 0;

    try {
      const auth = resolveModelAuth(profile);
      if (!auth) {
        const codexHint = profile.model.toLowerCase().includes("codex")
          ? " or login via Codex CLI (`~/.codex/auth.json`)"
          : "";
        const message = `Missing API key for model '${profile.model}'. Set env ${profile.apiKeyEnv} or config.models.${profileKey}.apiKey${codexHint}`;
        this.workspace.finalizeSession(session, false, message);
        this.workspace.appendDailyMemory(profileKey, task, false, message);
        return {
          ok: false,
          message,
          sessionPath: session.path,
        };
      }

      const model = new ModelClient(profile, auth.apiKey, {
        baseUrl: auth.baseUrl,
        preferredMode: auth.preferredMode,
      });
      const history: string[] = [];
      const traces: StepTrace[] = [];
      const skillsSummary = this.skillLoader.summaryText();
      const workspacePromptContext = this.buildWorkspacePromptContext();
      const systemPrompt = buildSystemPrompt(skillsSummary, workspacePromptContext);

      for (let step = 1; step <= this.config.agent.maxSteps; step += 1) {
        if (this.stopRequested) {
          const message = "Task stopped by user.";
          this.workspace.finalizeSession(session, false, message);
          this.workspace.appendDailyMemory(profileKey, task, false, message);
          return {
            ok: false,
            message,
            sessionPath: session.path,
          };
        }

        const snapshot = await this.adb.captureScreenSnapshot(this.config.agent.deviceId, profile.model);
        shouldReturnHome = true;
        let screenshotPath: string | null = null;
        if (this.config.screenshots.saveStepScreenshots) {
          try {
            screenshotPath = this.screenshotStore.save(
              Buffer.from(snapshot.screenshotBase64, "base64"),
              {
                sessionId: session.id,
                step,
                currentApp: snapshot.currentApp,
              },
            );
          } catch {
            screenshotPath = null;
          }
        }

        const autoPermissionDialogDetected =
          this.config.humanAuth.enabled &&
          typeof onHumanAuth === "function" &&
          AUTO_PERMISSION_DIALOG_PACKAGES.some((token) =>
            snapshot.currentApp.toLowerCase().includes(token),
          ) &&
          Date.now() - lastAutoPermissionAuthAtMs >= 15_000;

        if (autoPermissionDialogDetected && onHumanAuth) {
          lastAutoPermissionAuthAtMs = Date.now();
          const autoThought =
            "Detected Android runtime permission dialog. Escalating to human authorization.";
          const autoAction = {
            type: "request_human_auth",
            capability: "permission",
            instruction:
              "A system permission dialog is blocking automation. Review and approve or reject this permission from your real device.",
            timeoutSec: Math.max(30, Math.round(this.config.humanAuth.requestTimeoutSec)),
            reason: "auto_detected_android_permission_dialog",
          } as const;

          let decision: HumanAuthDecision;
          try {
            decision = await onHumanAuth({
              sessionId: session.id,
              sessionPath: session.path,
              task,
              step,
              capability: autoAction.capability,
              instruction: autoAction.instruction,
              reason: autoAction.reason ?? autoThought,
              timeoutSec: autoAction.timeoutSec,
              currentApp: snapshot.currentApp,
              screenshotPath,
            });
          } catch (error) {
            decision = {
              requestId: "local-error",
              approved: false,
              status: "rejected",
              message: `Human auth bridge error: ${(error as Error).message}`,
              decidedAt: nowIso(),
              artifactPath: null,
            };
          }

          const delegation = await this.applyHumanDelegation(
            autoAction.capability,
            decision,
            snapshot.currentApp,
          );
          const delegationResult = delegation?.message ?? null;
          const delegationTemplate = delegation?.templateHint ?? null;
          const decisionLine = delegationResult
            ? `Human auth ${decision.status} request_id=${decision.requestId} message=${decision.message} delegation=${delegationResult}`
            : `Human auth ${decision.status} request_id=${decision.requestId} message=${decision.message}`;
          const stepResultBase = decision.artifactPath
            ? `${decisionLine}\nhuman_artifact=${decision.artifactPath}`
            : decisionLine;
          const stepResultWithDelegation = delegationResult
            ? `${stepResultBase}\ndelegation_result=${delegationResult}${delegationTemplate ? `\ndelegation_template=${delegationTemplate}` : ""}`
            : stepResultBase;
          const stepResult = screenshotPath
            ? `${stepResultWithDelegation}\nlocal_screenshot=${screenshotPath}`
            : stepResultWithDelegation;

          this.workspace.appendStep(
            session,
            step,
            autoThought,
            JSON.stringify(autoAction, null, 2),
            stepResult,
          );
          traces.push({
            step,
            action: autoAction,
            result: stepResult,
            thought: autoThought,
            currentApp: snapshot.currentApp,
          });
          history.push(
            `step ${step}: app=${snapshot.currentApp} action=request_human_auth(auto_permission_dialog) decision=${decision.status} message=${decision.message}${delegationResult ? ` delegation=${delegationResult}` : ""}`,
          );
          if (delegationTemplate) {
            history.push(`delegation_template ${delegationTemplate}`);
          }

          if (onProgress && step % this.config.agent.progressReportInterval === 0) {
            try {
              await onProgress({
                step,
                maxSteps: this.config.agent.maxSteps,
                currentApp: snapshot.currentApp,
                actionType: autoAction.type,
                message: decisionLine,
                thought: autoThought,
                screenshotPath,
              });
            } catch {
              // Keep task execution unaffected when progress callback fails.
            }
          }

          if (!decision.approved) {
            const message = `Human authorization ${decision.status}: ${decision.message}`;
            this.workspace.finalizeSession(session, false, message);
            this.workspace.appendDailyMemory(profileKey, task, false, message);
            return {
              ok: false,
              message,
              sessionPath: session.path,
            };
          }

          await sleep(Math.min(this.config.agent.loopDelayMs, 1200));
          continue;
        }

        const output = await model.nextStep({
          systemPrompt,
          task,
          step,
          snapshot,
          history,
        });

        if (output.action.type === "finish") {
          const finishMessage = output.action.message || "Task completed.";
          this.workspace.appendStep(
            session,
            step,
            output.thought,
            JSON.stringify(output.action, null, 2),
            `FINISH: ${finishMessage}`,
          );
          traces.push({
            step,
            action: output.action,
            result: `FINISH: ${finishMessage}`,
            thought: output.thought,
            currentApp: snapshot.currentApp,
          });
          this.workspace.finalizeSession(session, true, finishMessage);
          this.workspace.appendDailyMemory(profileKey, task, true, finishMessage);
          const artifacts = this.autoArtifactBuilder.build({
            task,
            sessionPath: session.path,
            ok: true,
            finalMessage: finishMessage,
            traces,
          });
          if (artifacts.skillPath) {
            // eslint-disable-next-line no-console
            console.log(`[OpenPocket][artifact] auto skill generated: ${artifacts.skillPath}`);
          }
          if (artifacts.scriptPath) {
            // eslint-disable-next-line no-console
            console.log(`[OpenPocket][artifact] auto script generated: ${artifacts.scriptPath}`);
          }
          return {
            ok: true,
            message: finishMessage,
            sessionPath: session.path,
          };
        }

        if (output.action.type === "request_human_auth") {
          const timeoutSec = Math.max(
            30,
            Math.round(output.action.timeoutSec ?? this.config.humanAuth.requestTimeoutSec),
          );

          if (!onHumanAuth) {
            const message = `Human authorization required (${output.action.capability}), but no human auth handler is configured.`;
            const stepResult = screenshotPath
              ? `${message}\nlocal_screenshot=${screenshotPath}`
              : message;
            this.workspace.appendStep(
              session,
              step,
              output.thought,
              JSON.stringify(output.action, null, 2),
              stepResult,
            );
            traces.push({
              step,
              action: output.action,
              result: stepResult,
              thought: output.thought,
              currentApp: snapshot.currentApp,
            });
            this.workspace.finalizeSession(session, false, message);
            this.workspace.appendDailyMemory(profileKey, task, false, message);
            return {
              ok: false,
              message,
              sessionPath: session.path,
            };
          }

          let decision: HumanAuthDecision;
          try {
            decision = await onHumanAuth({
              sessionId: session.id,
              sessionPath: session.path,
              task,
              step,
              capability: output.action.capability,
              instruction: output.action.instruction,
              reason: output.action.reason ?? output.thought,
              timeoutSec,
              currentApp: snapshot.currentApp,
              screenshotPath,
            });
          } catch (error) {
            decision = {
              requestId: "local-error",
              approved: false,
              status: "rejected",
              message: `Human auth bridge error: ${(error as Error).message}`,
              decidedAt: nowIso(),
              artifactPath: null,
            };
          }

          const delegation = await this.applyHumanDelegation(
            output.action.capability,
            decision,
            snapshot.currentApp,
          );
          const delegationResult = delegation?.message ?? null;
          const delegationTemplate = delegation?.templateHint ?? null;
          const decisionLine = delegationResult
            ? `Human auth ${decision.status} request_id=${decision.requestId} message=${decision.message} delegation=${delegationResult}`
            : `Human auth ${decision.status} request_id=${decision.requestId} message=${decision.message}`;
          const stepResultBase = decision.artifactPath
            ? `${decisionLine}\nhuman_artifact=${decision.artifactPath}`
            : decisionLine;
          const stepResultWithDelegation = delegationResult
            ? `${stepResultBase}\ndelegation_result=${delegationResult}${delegationTemplate ? `\ndelegation_template=${delegationTemplate}` : ""}`
            : stepResultBase;
          const stepResult = screenshotPath
            ? `${stepResultWithDelegation}\nlocal_screenshot=${screenshotPath}`
            : stepResultWithDelegation;

          this.workspace.appendStep(
            session,
            step,
            output.thought,
            JSON.stringify(output.action, null, 2),
            stepResult,
          );
          traces.push({
            step,
            action: output.action,
            result: stepResult,
            thought: output.thought,
            currentApp: snapshot.currentApp,
          });
          history.push(
            `step ${step}: app=${snapshot.currentApp} action=request_human_auth decision=${decision.status} message=${decision.message}${delegationResult ? ` delegation=${delegationResult}` : ""}`,
          );
          if (delegationTemplate) {
            history.push(`delegation_template ${delegationTemplate}`);
          }

          if (onProgress && step % this.config.agent.progressReportInterval === 0) {
            try {
              await onProgress({
                step,
                maxSteps: this.config.agent.maxSteps,
                currentApp: snapshot.currentApp,
                actionType: output.action.type,
                message: decisionLine,
                thought: output.thought,
                screenshotPath,
              });
            } catch {
              // Keep task execution unaffected when progress callback fails.
            }
          }

          if (!decision.approved) {
            const message = `Human authorization ${decision.status}: ${decision.message}`;
            this.workspace.finalizeSession(session, false, message);
            this.workspace.appendDailyMemory(profileKey, task, false, message);
            return {
              ok: false,
              message,
              sessionPath: session.path,
            };
          }

          await sleep(Math.min(this.config.agent.loopDelayMs, 1200));
          continue;
        }

        // Save debug screenshot with marker overlay before scaling coordinates.
        if (
          this.config.screenshots.saveStepScreenshots &&
          (output.action.type === "tap" || output.action.type === "swipe")
        ) {
          try {
            const scaledBuf = Buffer.from(snapshot.screenshotBase64, "base64");
            const annotated = await drawDebugMarker(scaledBuf, output.action);
            this.screenshotStore.save(annotated, {
              sessionId: session.id,
              step,
              currentApp: `${snapshot.currentApp}-debug`,
            });
          } catch {
            // Debug overlay is best-effort; don't break the task loop.
          }
        }

        // Scale model-returned coordinates back to original device resolution.
        if (output.action.type === "tap") {
          const scaled = scaleCoordinates(
            output.action.x, output.action.y,
            snapshot.scaleX, snapshot.scaleY,
            snapshot.width, snapshot.height,
          );
          output.action.x = scaled.x;
          output.action.y = scaled.y;
        } else if (output.action.type === "swipe") {
          const p1 = scaleCoordinates(
            output.action.x1, output.action.y1,
            snapshot.scaleX, snapshot.scaleY,
            snapshot.width, snapshot.height,
          );
          const p2 = scaleCoordinates(
            output.action.x2, output.action.y2,
            snapshot.scaleX, snapshot.scaleY,
            snapshot.width, snapshot.height,
          );
          output.action.x1 = p1.x;
          output.action.y1 = p1.y;
          output.action.x2 = p2.x;
          output.action.y2 = p2.y;
        }

        let executionResult = "";
        try {
          if (output.action.type === "run_script") {
            const scriptResult = await this.scriptExecutor.execute(
              output.action.script,
              output.action.timeoutSec,
            );
            executionResult = [
              `run_script exitCode=${scriptResult.exitCode} timedOut=${scriptResult.timedOut}`,
              `runDir=${scriptResult.runDir}`,
              scriptResult.stdout ? `stdout=${scriptResult.stdout}` : "",
              scriptResult.stderr ? `stderr=${scriptResult.stderr}` : "",
            ]
              .filter(Boolean)
              .join("\n");
          } else {
            executionResult = await this.adb.executeAction(output.action, this.config.agent.deviceId);
          }
        } catch (error) {
          executionResult = `Action execution error: ${(error as Error).message}`;
        }

        const stepResult = screenshotPath
          ? `${executionResult}\nlocal_screenshot=${screenshotPath}`
          : executionResult;
        this.workspace.appendStep(
          session,
          step,
          output.thought,
          JSON.stringify(output.action, null, 2),
          stepResult,
        );
        traces.push({
          step,
          action: output.action,
          result: stepResult,
          thought: output.thought,
          currentApp: snapshot.currentApp,
        });

        history.push(
          `step ${step}: app=${snapshot.currentApp} thought="${output.thought}" action=${output.action.type} result=${executionResult}`,
        );

        if (this.config.agent.verbose) {
          // eslint-disable-next-line no-console
          console.log(`[OpenPocket][step ${step}] ${output.action.type}: ${executionResult}`);
        }

        if (onProgress && step % this.config.agent.progressReportInterval === 0) {
          try {
            await onProgress({
              step,
              maxSteps: this.config.agent.maxSteps,
              currentApp: snapshot.currentApp,
              actionType: output.action.type,
              message: executionResult,
              thought: output.thought,
              screenshotPath,
            });
          } catch {
            // Keep task execution unaffected when progress callback fails.
          }
        }

        if (output.action.type !== "wait") {
          await sleep(this.config.agent.loopDelayMs);
        }
      }

      const message = `Max steps reached (${this.config.agent.maxSteps})`;
      this.workspace.finalizeSession(session, false, message);
      this.workspace.appendDailyMemory(profileKey, task, false, message);
      return {
        ok: false,
        message,
        sessionPath: session.path,
      };
    } catch (error) {
      const message = `Agent execution failed: ${(error as Error).message}`;
      this.workspace.finalizeSession(session, false, message);
      this.workspace.appendDailyMemory(profileKey, task, false, message);
      return {
        ok: false,
        message,
        sessionPath: session.path,
      };
    } finally {
      if (shouldReturnHome) {
        await this.safeReturnToHome();
      }
      this.busy = false;
      this.currentTask = null;
      this.currentTaskStartedAtMs = null;
      this.stopRequested = false;
    }
  }
}
