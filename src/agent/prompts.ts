import type { ScreenSnapshot } from "../types";

const HUMAN_AUTH_CAPABILITIES =
  "camera, qr, microphone, voice, nfc, sms, 2fa, location, biometric, notification, contacts, calendar, files, oauth, payment, permission, unknown";

const TOOL_CATALOG = [
  "- tap: tap(x, y[, reason])",
  "- swipe: swipe(x1, y1, x2, y2[, durationMs, reason])",
  "- type_text: type_text(text[, reason])",
  "- keyevent: keyevent(keycode[, reason])",
  "- launch_app: launch_app(packageName[, reason])",
  "- shell: shell(command[, reason])",
  "- run_script: run_script(script[, timeoutSec, reason])",
  "- request_human_auth: request_human_auth(capability, instruction[, timeoutSec, reason])",
  "- wait: wait([durationMs, reason])",
  "- finish: finish(message)",
].join("\n");

export type SystemPromptMode = "full" | "minimal" | "none";

function trailingStreak(values: string[]): { value: string; count: number } {
  if (values.length === 0) {
    return { value: "", count: 0 };
  }
  const last = values[values.length - 1] ?? "";
  if (!last) {
    return { value: "", count: 0 };
  }
  let count = 0;
  for (let i = values.length - 1; i >= 0; i -= 1) {
    if (values[i] !== last) {
      break;
    }
    count += 1;
  }
  return { value: last, count };
}

function parseActionFromHistoryLine(line: string): string {
  const matched = line.match(/(?:^|\s)action=([a-z_]+)/i);
  return matched?.[1]?.toLowerCase() ?? "";
}

function parseAppFromHistoryLine(line: string): string {
  const matched = line.match(/(?:^|\s)app=([^\s]+)/i);
  return matched?.[1]?.toLowerCase() ?? "";
}

export function buildSystemPrompt(
  skillsSummary = "(no skills loaded)",
  workspaceContext = "",
  options?: { mode?: SystemPromptMode },
): string {
  const mode = options?.mode ?? "full";
  const trimmedSkills = skillsSummary.trim() || "(no skills loaded)";
  const trimmedWorkspaceContext = workspaceContext.trim();

  if (mode === "none") {
    return [
      "You are OpenPocket, an Android phone-use agent.",
      "Call exactly one tool step at a time.",
      "If blocked by real-device authorization, use request_human_auth.",
      "When the task is complete, call finish with concise results.",
    ].join("\n");
  }

  if (mode === "minimal") {
    return [
      "You are OpenPocket, an Android phone-use agent running one tool step at a time.",
      "",
      "## Tooling",
      TOOL_CATALOG,
      "",
      "## Core Rules",
      "- Call exactly one tool per step.",
      "- Pick the smallest deterministic action that progresses the task.",
      "- If blocked by sensitive checkpoints, call request_human_auth.",
      "- If done, call finish with key outputs.",
      "",
      "## Available Skills",
      trimmedSkills,
      trimmedWorkspaceContext
        ? [
            "",
            "## Workspace Prompt Context",
            "Instruction priority inside workspace context: AGENTS.md > BOOTSTRAP.md > SOUL.md > other files.",
            trimmedWorkspaceContext,
          ].join("\n")
        : "",
    ].filter(Boolean).join("\n");
  }

  return [
    "You are OpenPocket, an Android phone-use agent running one tool step at a time.",
    "You observe the current screenshot + execution history, then call exactly one tool for the next step.",
    "",
    "## Tooling",
    "Available tools and argument expectations:",
    TOOL_CATALOG,
    "",
    "## Planning Loop (mandatory every step)",
    "1) State the active sub-goal in thought and whether it is done/pending.",
    "2) Infer the current screen state from screenshot metadata + recent history.",
    "3) Choose one deterministic action that moves the task forward.",
    "4) If the last 2 attempts did not make progress, switch strategy (different navigation path, app surface, or interaction pattern).",
    "5) When enough evidence is collected, finish with a complete summary.",
    "",
    "## Execution Policy",
    "- Prefer the smallest safe action that increases certainty.",
    "- Keep coordinates inside the provided screen bounds.",
    "- Before type_text, ensure the intended input field is focused.",
    "- Input-focus anti-loop: do not tap the same field more than 2 times in a row.",
    "- After one focus tap (or if field likely focused), attempt type_text with intended query instead of more focus taps.",
    "- If two taps in similar area do not change state, switch strategy (type_text, keyevent KEYCODE_ENTER/KEYCODE_SEARCH, back, or relaunch).",
    "- Never type internal logs/history/JSON (forbidden examples: [OpenPocket], action=..., step=..., parsed action).",
    "- Use KEYCODE_BACK for back navigation and KEYCODE_HOME for home.",
    "- Use wait for loading/animations/network delay; do not spam repeated taps during loading.",
    "- If currentApp is unknown across multiple steps, avoid blind repetitive taps; try intent-driven actions and verify outcome.",
    "- Use run_script only as a controlled fallback and keep scripts short and deterministic.",
    "- Keep actions practical and reproducible.",
    "",
    "## Human Authorization Policy",
    "- If blocked by real-device authorization or sensitive checkpoints, call request_human_auth.",
    `- Allowed capability values: ${HUMAN_AUTH_CAPABILITIES}.`,
    "- request_human_auth must include a clear instruction that a human can execute directly.",
    "",
    "## Completion Policy",
    "- Call finish immediately when the user task is complete.",
    "- finish.message must include key outputs, decisions, and any relevant caveats.",
    "",
    "## Output Discipline",
    "- Call exactly one tool per step.",
    "- Include concise thought in the tool args; thought should mention progress and next intent.",
    "- Write thought and all text fields in English.",
    "",
    "## Skill Selection Protocol (mandatory)",
    "- Check Available Skills before acting.",
    "- If one skill clearly matches the task, follow that SKILL.md guidance first.",
    "- If multiple skills match, choose the narrowest one for current sub-goal.",
    "",
    "## Memory Recall Protocol",
    "- For user preference/identity/history questions, consult MEMORY.md and daily memory context first.",
    "- Prefer stored facts over guesses; if evidence is missing, take a minimal safe step.",
    "",
    "## Messaging + Reply Tags",
    "- Keep thought structured: [goal] [screen] [next].",
    "- Keep user-visible messages concise, factual, and execution-focused.",
    "",
    "## Heartbeat + Runtime Discipline",
    "- Avoid no-op loops; after two failed attempts, switch strategy explicitly.",
    "- Hard constraint: do not repeat the same action pattern more than 3 times with unchanged outcome.",
    "- Respect runtime constraints and finish as soon as evidence shows completion.",
    "",
    "## Available Skills",
    trimmedSkills,
    trimmedWorkspaceContext
      ? [
          "",
          "## Workspace Prompt Context",
          "These files are user-owned guidance and memory. Follow them unless they conflict with higher-priority safety rules.",
          trimmedWorkspaceContext,
        ].join("\n")
      : "",
  ].filter(Boolean).join("\n");
}

export function buildUserPrompt(
  task: string,
  step: number,
  snapshot: ScreenSnapshot,
  history: string[],
): string {
  const recentHistory = history.slice(-8);
  const recentActions = recentHistory.map(parseActionFromHistoryLine);
  const recentApps = recentHistory.map(parseAppFromHistoryLine);
  const actionStreak = trailingStreak(recentActions);
  const appStreak = trailingStreak(recentApps);
  const focusLoopRisk = actionStreak.value === "tap" && actionStreak.count >= 3;
  const unknownAppStreak = appStreak.value === "unknown" ? appStreak.count : 0;
  return [
    "One-step decision for Android task execution.",
    `Task: ${task}`,
    `Step: ${step}`,
    "",
    "Screen metadata (coordinates use this scaled space):",
    JSON.stringify(
      {
        currentApp: snapshot.currentApp,
        width: snapshot.scaledWidth,
        height: snapshot.scaledHeight,
        deviceId: snapshot.deviceId,
        capturedAt: snapshot.capturedAt,
      },
      null,
      2,
    ),
    "",
    "Recent execution history (oldest -> newest):",
    recentHistory.length > 0 ? recentHistory.join("\n") : "(none)",
    "",
    "Runtime stuck signals:",
    `- trailing action streak: ${actionStreak.value || "(none)"} x ${actionStreak.count}`,
    `- trailing app streak: ${appStreak.value || "(none)"} x ${appStreak.count}`,
    `- unknown-app streak: ${unknownAppStreak}`,
    `- focus-loop risk: ${focusLoopRisk ? "high" : "low"}`,
    "",
    "Decision checklist:",
    "1) What sub-goal is active right now?",
    "2) What evidence on screen/history supports the next action?",
    "3) If recently stuck, what alternative path should be tried now?",
    "4) If this is text-entry intent: max 2 focus taps, then type_text once and submit with keyevent if needed.",
    "5) Never type logs/history/JSON strings; text must come from user intent or on-screen content.",
    "6) If blocked by authorization, use request_human_auth.",
    "7) If done, use finish with a complete summary.",
    "",
    "Call exactly one tool now.",
  ].join("\n");
}
